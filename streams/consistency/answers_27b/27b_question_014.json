{
  "stream": "consistency",
  "category": "Computer Science B",
  "question": "How do you efficiently find an item in a sorted list?",
  "answer": "## Efficiently Finding an Item in a Sorted List: Binary Search\n\nThe most efficient way to find an item in a sorted list is using **Binary Search**. Here's a breakdown of how it works and why it's efficient:\n\n**How Binary Search Works:**\n\n1. **Start with the middle element:**  Examine the element in the middle of the sorted list.\n2. **Compare:**\n   * **If the middle element is equal to the item you're searching for:** You've found it!  Return the index of the middle element.\n   * **If the item you're searching for is less than the middle element:**  Discard the right half of the list (since everything to the right is greater).  Repeat the process on the left half.\n   * **If the item you're searching for is greater than the middle element:** Discard the left half of the list (since everything to the left is smaller). Repeat the process on the right half.\n3. **Repeat:**  Continue this process of dividing the search space in half until:\n   * You find the item.\n   * The search space is empty (meaning the item is not in the list).\n\n**Example:**\n\nLet's say we have the sorted list: `[2, 5, 7, 8, 11, 12]` and we want to find the number `12`.\n\n1. **Middle element:** The middle element is `7` (index 2).  `12 > 7`, so we discard the left half.\n2. **Remaining list:** `[8, 11, 12]`  Middle element is `11` (index 4). `12 > 11`, so we discard the left half.\n3. **Remaining list:** `[12]` Middle element is `12` (index 5). `12 == 12`, we found it!\n\n**Implementation (Python):**\n\n```python\ndef binary_search(sorted_list, item):\n  \"\"\"\n  Performs binary search on a sorted list.\n\n  Args:\n    sorted_list: The sorted list to search.\n    item: The item to search for.\n\n  Returns:\n    The index of the item if found, otherwise -1.\n  \"\"\"\n  low = 0\n  high = len(sorted_list) - 1\n\n  while low <= high:\n    mid = (low + high) // 2  # Integer division to get the middle index\n    guess = sorted_list[mid]\n\n    if guess == item:\n      return mid\n    if guess > item:\n      high = mid - 1\n    else:\n      low = mid + 1\n\n  return -1  # Item not found\n\n#Example\nmy_list = [2, 5, 7, 8, 11, 12]\nprint(binary_search(my_list, 12))  # Output: 5\nprint(binary_search(my_list, 13))  # Output: -1\n```\n\n**Why Binary Search is Efficient (Time Complexity):**\n\n* **O(log n):**  This is the crucial part.  Binary search's time complexity is logarithmic.  This means that as the size of the list (n) increases, the number of steps required to find the item increases *much* slower than a linear search (O(n)).\n\n   * With a list of 10 items, it might take about 3-4 comparisons.\n   * With a list of 1000 items, it might take about 10 comparisons.\n   * With a list of 1,000,000 items, it might take about 20 comparisons.\n\n* **Linear Search (for comparison):** In contrast, a linear search (checking each element one by one) would take, on average, n/2 comparisons, and in the worst case, n comparisons.\n\n\n**Key Requirements:**\n\n* **Sorted List:** Binary search *only* works on sorted lists. If the list is not sorted, you must sort it first (which itself has a time complexity, usually O(n log n) for efficient sorting algorithms like merge sort or quicksort).\n* **Random Access:**  Binary search requires the ability to quickly access elements by their index (random access).  This is efficient for arrays and lists, but less efficient for some data structures like linked lists.\n\n\n**Alternatives (and why they're generally less efficient for sorted lists):**\n\n* **Linear Search:**  Simple, but inefficient for large sorted lists. O(n) time complexity.\n* **Interpolation Search:**  An improvement over binary search if the list is uniformly distributed, but it can have a worst-case complexity of O(n) if the data isn't well-distributed.\n* **Jump Search:** Another method that's better than linear search but generally not as good as binary search.\n\n\n\n**In Summary:**\n\nBinary search is the most efficient algorithm for finding an item in a sorted list, offering a logarithmic time complexity (O(log n)) that makes it suitable for very large datasets.  Its requirement of a sorted list is a trade-off, but often a worthwhile one given the significant performance benefits.",
  "index": 14
}