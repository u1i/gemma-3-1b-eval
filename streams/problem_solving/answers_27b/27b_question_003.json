{
  "stream": "problem_solving",
  "category": "Algorithms",
  "question": "Design an algorithm to find the longest palindrome in a string. Explain your approach step by step.",
  "answer": "## Algorithm to Find the Longest Palindrome in a String\n\nHere's an algorithm to find the longest palindrome in a given string, along with a step-by-step explanation.  We'll utilize the **Dynamic Programming** approach for this.\n\n**Approach:**\n\nThe core idea is to leverage the fact that a palindrome can be built up from smaller palindromes.  We'll create a 2D boolean table `dp` where `dp[i][j]` will be `true` if the substring `s[i...j]` is a palindrome, and `false` otherwise.\n\n**Steps:**\n\n1. **Initialization:**\n   - Let `n` be the length of the input string `s`.\n   - Create a 2D boolean table `dp` of size `n x n`, initialized to `false`.\n   - All single characters are palindromes:  Set `dp[i][i] = true` for all `i` from 0 to `n-1`.\n\n2. **Consider Substrings of Length 2:**\n   - Iterate through the string from `i = 0` to `n-2`.\n   - If `s[i] == s[i+1]`, then `dp[i][i+1] = true`. This means substrings of length 2 are palindromes if their characters match.\n\n3. **Consider Substrings of Length 3 and Greater:**\n   - Iterate through substring lengths `k` from 3 to `n`.\n   - For each `k`, iterate through possible starting indices `i` from 0 to `n - k`.\n   - Calculate the ending index `j = i + k - 1`.\n   - Check if `s[i] == s[j]` *and* `dp[i+1][j-1]` is `true` (meaning the inner substring is a palindrome).\n     - If both conditions are met, `dp[i][j] = true`. This means the substring `s[i...j]` is a palindrome.\n\n4. **Track the Longest Palindrome:**\n   - While filling the `dp` table, maintain variables `start` and `max_len` to keep track of the starting index of the longest palindrome found so far and its length, respectively.\n   - Whenever you find `dp[i][j] == true`, check if `j - i + 1 > max_len`.  If it is, update `start = i` and `max_len = j - i + 1`.\n\n5. **Extract the Longest Palindrome:**\n   - After filling the `dp` table, extract the longest palindrome substring using `s[start: start + max_len]`.\n\n**Pseudocode:**\n\n```\nfunction longestPalindrome(s):\n  n = length(s)\n  dp = 2D boolean array of size n x n, initialized to false\n  start = 0\n  max_len = 1\n\n  # All single characters are palindromes\n  for i from 0 to n-1:\n    dp[i][i] = true\n\n  # Check for palindromes of length 2\n  for i from 0 to n-2:\n    if s[i] == s[i+1]:\n      dp[i][i+1] = true\n      start = i\n      max_len = 2\n\n  # Check for palindromes of length 3 or greater\n  for k from 3 to n:\n    for i from 0 to n-k:\n      j = i + k - 1\n      if s[i] == s[j] and dp[i+1][j-1]:\n        dp[i][j] = true\n        if k > max_len:\n          start = i\n          max_len = k\n\n  return s[start: start + max_len]\n```\n\n**Example:**\n\nLet's say `s = \"babad\"`\n\n1. **Initialization:** `dp` is a 5x5 boolean array, all initialized to `false`. `dp[0][0]`, `dp[1][1]`, `dp[2][2]`, `dp[3][3]`, `dp[4][4]` are set to `true`. `start = 0`, `max_len = 1`.\n\n2. **Length 2:**\n   - `s[0] != s[1]`  (`b != a`)\n   - `s[1] == s[2]` (`a == b`) - False.\n   - `s[2] == s[3]` (`b == a`) - False.\n   - `s[3] == s[4]` (`a == d`) - False.\n\n3. **Length 3:**\n   - `k = 3`:  `i = 0`, `j = 2`. `s[0] == s[2]` (`b == b`) and `dp[1][1]` is `true`. So, `dp[0][2] = true`. `max_len` becomes 3, `start = 0`.\n   - `i = 1`, `j = 3`. `s[1] == s[3]` (`a == a`) and `dp[2][2]` is `true`. So, `dp[1][3] = true`. `max_len` remains 3, `start = 0` (since the lengths are the same).\n   - `i = 2`, `j = 4`. `s[2] == s[4]` (`b == d`) - False.\n\n4. **Length 4:**\n   - `k = 4`:  `i = 0`, `j = 3`.  `s[0] == s[3]` (`b == a`) - False.\n   - `i = 1`, `j = 4`.  `s[1] == s[4]` (`a == d`) - False.\n\n5. **Length 5:**\n   - `k = 5`:  `i = 0`, `j = 4`. `s[0] == s[4]` (`b == d`) - False.\n\nFinally, the function returns `s[0: 0 + 3] = \"bab\"` or `s[0: 0 + 3] = \"aba\"` (since \"bab\" and \"aba\" both have length 3 and both can be valid answers.)\n\n**Time and Space Complexity:**\n\n- **Time Complexity:** O(n^2) \u2013 Due to the nested loops for filling the `dp` table.\n- **Space Complexity:** O(n^2) \u2013  For storing the `dp` table.\n\n**Advantages of Dynamic Programming:**\n\n- **Efficient:** Avoids redundant calculations by storing and reusing results in the `dp` table.\n- **Clear and Understandable:** The logic is relatively easy to follow.\n\n**Alternative Approaches (Less Efficient):**\n\n- **Brute Force:**  Checking all possible substrings for palindromes. O(n^3) time complexity.\n- **Expand Around Center:**  Iterating through each character in the string and expanding outwards to find palindromes.  O(n^2) time complexity, but often faster in practice than dynamic programming due to less overhead. However, it still requires checking each center point.",
  "index": 3
}